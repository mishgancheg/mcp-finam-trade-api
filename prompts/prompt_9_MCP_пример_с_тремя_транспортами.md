# –ü—Ä–∏–º–µ—Ä MCP —Å–µ—Ä–≤–µ—Ä–∞ —Å —Ç—Ä–µ–º—è —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞–º–∏

## src/index.ts

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import express from "express";

// ==========================================
// –°–æ–∑–¥–∞–Ω–∏–µ MCP —Å–µ—Ä–≤–µ—Ä–∞
// ==========================================
function createMCPServer() {
  const server = new Server(
    {
      name: "multi-transport-example",
      version: "1.0.0",
    },
    {
      capabilities: {
        tools: {},
        resources: {},
      },
    }
  );

  // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞: get_current_time
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
      tools: [
        {
          name: "get_current_time",
          description: "Returns current server time",
          inputSchema: {
            type: "object",
            properties: {
              timezone: {
                type: "string",
                description: "Timezone (e.g., UTC, Europe/Moscow)",
                default: "UTC",
              },
            },
          },
        },
        {
          name: "echo",
          description: "Echoes back the provided message",
          inputSchema: {
            type: "object",
            properties: {
              message: {
                type: "string",
                description: "Message to echo",
              },
            },
            required: ["message"],
          },
        },
      ],
    };
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    try {
      if (name === "get_current_time") {
        const timezone = (args?.timezone as string) || "UTC";
        const now = new Date();
        const timeString = now.toLocaleString("en-US", {
          timeZone: timezone,
          dateStyle: "full",
          timeStyle: "long",
        });

        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  timezone,
                  time: timeString,
                  timestamp: now.getTime(),
                },
                null,
                2
              ),
            },
          ],
        };
      }

      if (name === "echo") {
        const message = args?.message as string;
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  echoed: message,
                  length: message.length,
                  timestamp: new Date().toISOString(),
                },
                null,
                2
              ),
            },
          ],
        };
      }

      throw new Error(`Unknown tool: ${name}`);
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: error instanceof Error ? error.message : String(error),
            }),
          },
        ],
        isError: true,
      };
    }
  });

  return server;
}

// ==========================================
// STDIO Transport
// ==========================================
async function startStdioServer() {
  const server = createMCPServer();
  const transport = new StdioServerTransport();
  
  await server.connect(transport);
  
  // –õ–æ–≥–∏—Ä—É–µ–º –≤ stderr (stdout –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è MCP –ø—Ä–æ—Ç–æ–∫–æ–ª–∞)
  console.error("MCP Server started in STDIO mode");
  console.error("Ready to accept requests via stdin/stdout");
}

// ==========================================
// HTTP Server (SSE + Streamable HTTP)
// ==========================================
async function startHTTPServer() {
  const app = express();
  app.use(express.json());

  // –•—Ä–∞–Ω–∏–ª–∏—â–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö SSE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
  const sseConnections = new Map<string, SSEServerTransport>();

  // ========================================
  // SSE Transport
  // ========================================
  
  // SSE endpoint - —Å–æ–∑–¥–∞–µ—Ç stream –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–æ–≤
  app.get("/sse", async (req, res) => {
    const sessionId = `sse-${Date.now()}-${Math.random()}`;
    console.log(`[SSE] New connection: ${sessionId}`);

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ SSE –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("Access-Control-Allow-Origin", "*");

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π MCP —Å–µ—Ä–≤–µ—Ä –¥–ª—è —ç—Ç–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    const mcpServer = createMCPServer();
    const transport = new SSEServerTransport("/message", res);
    
    sseConnections.set(sessionId, transport);
    
    await mcpServer.connect(transport);

    req.on("close", () => {
      console.log(`[SSE] Connection closed: ${sessionId}`);
      sseConnections.delete(sessionId);
    });
  });

  // POST endpoint –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
  app.post("/message", async (req, res) => {
    console.log(`[SSE] Received message:`, req.body);
    // –ó–∞–ø—Ä–æ—Å—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ SSE transport –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    res.status(202).end();
  });

  // ========================================
  // Streamable HTTP Transport
  // ========================================
  
  app.post("/mcp/v1", async (req, res) => {
    const sessionId = `http-${Date.now()}-${Math.random()}`;
    console.log(`[Streamable HTTP] New connection: ${sessionId}`);

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –¥–ª—è streaming
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("Access-Control-Allow-Origin", "*");

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π MCP —Å–µ—Ä–≤–µ—Ä –¥–ª—è —ç—Ç–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    const mcpServer = createMCPServer();
    
    // Note: StreamableHTTPServerTransport —Ç—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    // –í —Ç–µ–∫—É—â–µ–π –≤–µ—Ä—Å–∏–∏ SDK —ç—Ç–æ –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é
    
    try {
      // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è newline-delimited JSON streaming
      let buffer = "";
      
      req.on("data", async (chunk) => {
        buffer += chunk.toString();
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.trim()) {
            try {
              const request = JSON.parse(line);
              console.log(`[Streamable HTTP] Request:`, request);
              
              // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π API —Å–µ—Ä–≤–µ—Ä–∞
              // (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è, –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ SDK —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç)
              res.write(JSON.stringify({ 
                jsonrpc: "2.0", 
                id: request.id,
                result: { status: "processed" }
              }) + "\n");
            } catch (err) {
              console.error(`[Streamable HTTP] Parse error:`, err);
            }
          }
        }
      });

      req.on("end", () => {
        console.log(`[Streamable HTTP] Connection ended: ${sessionId}`);
        res.end();
      });

      req.on("close", () => {
        console.log(`[Streamable HTTP] Connection closed: ${sessionId}`);
      });

    } catch (error) {
      console.error(`[Streamable HTTP] Error:`, error);
      res.status(500).end();
    }
  });

  // ========================================
  // Utility endpoints
  // ========================================
  
  app.get("/health", (req, res) => {
    res.json({
      status: "ok",
      transports: ["stdio", "sse", "streamable-http"],
      connections: {
        sse: sseConnections.size,
      },
      timestamp: new Date().toISOString(),
    });
  });

  app.get("/", (req, res) => {
    res.send(`
      <h1>MCP Multi-Transport Server</h1>
      <p>Server is running and supports multiple transports:</p>
      <ul>
        <li><strong>STDIO:</strong> Start with MCP_TRANSPORT=stdio</li>
        <li><strong>SSE:</strong> Connect to <code>GET /sse</code> and send messages to <code>POST /message</code></li>
        <li><strong>Streamable HTTP:</strong> Connect to <code>POST /mcp/v1</code></li>
      </ul>
      <p><a href="/health">Health Check</a></p>
    `);
  });

  // ========================================
  // Start HTTP server
  // ========================================
  
  const PORT = process.env.PORT || 3000;
  app.listen(PORT, () => {
    console.log(`\nüöÄ MCP Server running on port ${PORT}`);
    console.log(`\nAvailable endpoints:`);
    console.log(`  - SSE:              http://localhost:${PORT}/sse`);
    console.log(`  - SSE Messages:     http://localhost:${PORT}/message`);
    console.log(`  - Streamable HTTP:  http://localhost:${PORT}/mcp/v1`);
    console.log(`  - Health:           http://localhost:${PORT}/health`);
    console.log(`\nActive transports: SSE, Streamable HTTP`);
  });
}

// ==========================================
// Main entry point
// ==========================================

const transport = process.env.MCP_TRANSPORT || "http";

if (transport === "stdio") {
  startStdioServer().catch((error) => {
    console.error("Failed to start STDIO server:", error);
    process.exit(1);
  });
} else {
  startHTTPServer().catch((error) => {
    console.error("Failed to start HTTP server:", error);
    process.exit(1);
  });
}
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ Claude Desktop** (`claude_desktop_config.json`):
```json
{
  "mcpServers": {
    "multi-transport": {
      "command": "node",
      "args": ["/path/to/dist/index.js"],
      "env": {
        "MCP_TRANSPORT": "stdio"
      }
    }
  }
}
```

### 3. –ó–∞–ø—É—Å–∫ –≤ —Ä–µ–∂–∏–º–µ HTTP (SSE + Streamable HTTP)


**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ SSE:**
```bash
# –í –æ–¥–Ω–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ - –æ—Ç–∫—Ä—ã–≤–∞–µ–º SSE stream
curl -N http://localhost:3000/sse

# –í –¥—Ä—É–≥–æ–º —Ç–µ—Ä–º–∏–Ω–∞–ª–µ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
curl -X POST http://localhost:3000/message \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/list"
  }'
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Streamable HTTP:**
```bash
curl -X POST http://localhost:3000/mcp/v1 \
  -H "Content-Type: application/json" \
  -N \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list"}'
```

## –î–∏–∞–≥—Ä–∞–º–º–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            MCP Server Core Logic                    ‚îÇ
‚îÇ  (createMCPServer() - –æ–±—â–∞—è –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞)         ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  Tools:                                             ‚îÇ
‚îÇ  - get_current_time                                 ‚îÇ
‚îÇ  - echo                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ              ‚îÇ              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   STDIO     ‚îÇ  ‚îÇ  SSE   ‚îÇ  ‚îÇ Streamable    ‚îÇ
    ‚îÇ  Transport  ‚îÇ  ‚îÇTransport‚îÇ  ‚îÇ HTTP Transport‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ             ‚îÇ               ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ stdin/stdout‚îÇ  ‚îÇ GET /sse‚îÇ  ‚îÇ POST /mcp/v1  ‚îÇ
    ‚îÇ             ‚îÇ  ‚îÇPOST /msg‚îÇ  ‚îÇ               ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ             ‚îÇ               ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇClaude Desktop‚îÇ ‚îÇBrowser ‚îÇ  ‚îÇ CLI / Server  ‚îÇ
    ‚îÇ             ‚îÇ  ‚îÇClaude  ‚îÇ  ‚îÇ  Clients      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
